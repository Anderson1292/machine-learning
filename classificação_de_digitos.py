# -*- coding: utf-8 -*-
"""Classificação de Digitos

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qnZK2WChR61XqJB7AxZbvMbE32TBOKKn
"""

!pip uninstall -y tensorflow

!pip install tensorflow-gpu==2.11.0

from sklearn.model_selection import StratifiedKFold
from keras.datasets import mnist
from keras.layers import Dense,Conv2D,Flatten,MaxPooling2D,Dropout
from keras.utils import np_utils
from keras.models import Sequential
from keras.wrappers.scikit_learn import KerasClassifier
from keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import BatchNormalization
import numpy as np

(X_train,y_train),(X_test,y_test) = mnist.load_data()

X_train.shape,X_test.shape

X_train = X_train/255.0
X_test = X_test/255.0

predictors_train = X_train.reshape(X_train.shape[0],28,28,1)
predictors_test = X_test.reshape(X_test.shape[0],28,28,1)

predictors_train = predictors_train.astype('float32')
predictors_test = predictors_test.astype('float32')

class_train = np_utils.to_categorical(y_train,10)
class_test = np_utils.to_categorical(y_test,10)

#Implementação  da Rede Neural Convolucional
model = Sequential()
model.add(Conv2D(32,(3,3),input_shape=(28,28,1),activation='relu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))

model.add(Conv2D(32,(3,3),activation='relu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Flatten())

model.add(Dense(128,activation='relu'))
model.add(Dropout(0.25))
model.add(Dense(128,activation='relu'))
model.add(Dropout(0.25))

model.add(Dense(10,activation='softmax'))
model.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])

model.fit(predictors_train,class_train,batch_size=128,
          epochs=5,validation_data=(predictors_test,class_test))

#Adicionando mais imagens para treino e teste
gen_train = ImageDataGenerator(rotation_range=7,
                               horizontal_flip=True,
                               shear_range=0.2,
                               height_shift_range=0.07,
                               zoom_range=0.2)
gen_test = ImageDataGenerator()

base_train = gen_train.flow(predictors_train,class_train,batch_size=128)
base_test = gen_test.flow(predictors_test,class_test,batch_size=128)

model.fit(base_train,steps_per_epoch=60000/128,epochs=5,
          validation_data = base_test,validation_steps=10000/128)

#Validação cruzada
seed = 5
# np.random.seed(seed)
# classe = np_utils.to_categorical(y_train,10)
# predictors = X_train.reshape(X_train.shape[0],28,28,1)
# predictors = predictors.astype('float32')
# predictors = predictors/255.0

(X,y),(X_test,y_test) = mnist.load_data()
predictors = X.reshape(X.shape[0],28,28,1)
predictors = predictors.astype('float32')
predictors = predictors/255
classe = np_utils.to_categorical(y,10)

kfold = StratifiedKFold(n_splits=5,shuffle=True,random_state=seed)
results = []
for train,test in kfold.split(predictors,np.zeros(shape=(classe.shape[0],1))):
  modelo = Sequential()
  modelo.add(Conv2D(32,(3,3),input_shape=(28,28,1),activation='relu'))
  # modelo.add(BatchNormalization())
  modelo.add(MaxPooling2D(pool_size=(2,2)))

  # modelo.add(Conv2D(32,(3,3),activation='relu'))
  # modelo.add(BatchNormalization())
  # model.add(MaxPooling2D(pool_size=(2,2)))
  model.add(Flatten())

  modelo.add(Dense(128,activation='relu'))
  modelo.add(Dense(10,activation='softmax'))

  modelo.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])
  modelo.fit(predictors[train],classe[train],batch_size=128,epochs=5)

  precision = model.evaluate(predictors[test],classe[test])
  results.append(predictors[1])

media = sum(predictors)/len(predictors)
print(media)